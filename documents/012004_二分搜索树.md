# 二分搜索树

## 一、 引子，二分查找

对于有序数列才能使用二分查找法(排序的作用)

```javascript
// arr必须是有序的，如果找到返回索引，没有返回-1
// 由于受到快排、合并排序的影响，思维定势，我一开始的想法：递归，反而想复杂了
// 并且还犯了一个错误：idx传的是值，不是引用
function binarySearch(arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], target = 2) {
    let idx = -1;

    function __binarySearch(arr, l, r, idx) {
        const mid = Math.floor((l + r) / 2);
        if (arr[mid] === target) {
            idx = mid;
        } else if ((arr[mid] > target && l <= mid - 1)) {
            __binarySearch(arr, l, mid - 1, idx);
        } else if (mid + 1 <= r) {
            __binarySearch(arr, mid + 1, r, idx);
        }
    }
    __binarySearch(arr, 0, arr.length - 1, idx);

    return idx;
}

// 直接修改全局变量
function binarySearch(arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], target = 2) {
    let idx = -1;

    function __binarySearch(arr, l, r) {
        const mid = Math.floor((l + r) / 2);
        if (arr[mid] === target) {
            idx = mid;
        } else if ((arr[mid] > target && l <= mid - 1)) {
            __binarySearch(arr, l, mid - 1);
        } else if (mid + 1 <= r) {
            __binarySearch(arr, mid + 1, r);
        }
    }
    __binarySearch(arr, 0, arr.length - 1);

    return idx;
}
```

```javascript
// 递归没必要定义全局变量
function binarySearch(arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], target = 2) {
    function __binarySearch(arr, l, r) {
        if (l > r) return -1;

        const mid = Math.floor((l + r) / 2);
        if (arr[mid] === target) {
            return mid;
        } else if ((arr[mid] > target)) {
            return __binarySearch(arr, l, mid - 1);
        } else {
            return __binarySearch(arr, mid + 1, r);
        }
    }
    return __binarySearch(arr, 0, arr.length - 1);
}
```

```javascript
// 最优解，并且解决了遇到大数相加会越界的情况
function binarySearch(arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], target = 2) {
    let l = 0,
        r = arr.length - 1;
    while (l <= r) {
        // const mid = Math.floor((l + r) / 2); // 遇到大数相加会越界，改成下面方式规避大数相加的情况
        const mid = Math.floor(l + (r - l) / 2);
        if (arr[mid] === target) {
            return mid;
        } else if (arr[mid] > target) {
            r = mid - 1;
        } else {
            l = mid + 1;
        }
    }
    return -1;
}
```

## 二、二分查找的floor和ceil

```javascript
function floor() {
    // TODO
}

function ceil() {
    // TODO
}
```

## 三、二分查找树
