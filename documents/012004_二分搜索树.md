# 二分搜索树

## 一、 引子，二分查找

对于有序数列才能使用二分查找法(排序的作用)

```javascript
// arr必须是有序的，如果找到返回索引，没有返回-1
// 由于受到快排、合并排序的影响，思维定势，我一开始的想法：递归，反而想复杂了
// 并且还犯了一个错误：idx传的是值，不是引用
function binarySearch(arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], target = 2) {
    let idx = -1;

    function __binarySearch(arr, l, r, idx) {
        const mid = Math.floor((l + r) / 2);
        if (arr[mid] === target) {
            idx = mid;
        } else if ((arr[mid] > target && l <= mid - 1)) {
            __binarySearch(arr, l, mid - 1, idx);
        } else if (mid + 1 <= r) {
            __binarySearch(arr, mid + 1, r, idx);
        }
    }
    __binarySearch(arr, 0, arr.length - 1, idx);

    return idx;
}

// 直接修改全局变量
function binarySearch(arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], target = 2) {
    let idx = -1;

    function __binarySearch(arr, l, r) {
        const mid = Math.floor((l + r) / 2);
        if (arr[mid] === target) {
            idx = mid;
        } else if ((arr[mid] > target && l <= mid - 1)) {
            __binarySearch(arr, l, mid - 1);
        } else if (mid + 1 <= r) {
            __binarySearch(arr, mid + 1, r);
        }
    }
    __binarySearch(arr, 0, arr.length - 1);

    return idx;
}
```

```javascript
// 递归没必要定义全局变量
function binarySearch(arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], target = 2) {
    function __binarySearch(arr, l, r) {
        if (l > r) return -1;

        const mid = Math.floor((l + r) / 2);
        if (arr[mid] === target) {
            return mid;
        } else if ((arr[mid] > target)) {
            return __binarySearch(arr, l, mid - 1);
        } else {
            return __binarySearch(arr, mid + 1, r);
        }
    }
    return __binarySearch(arr, 0, arr.length - 1);
}
```

```javascript
// 最优解，并且解决了遇到大数相加会越界的情况
function binarySearch(arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], target = 2) {
    let l = 0,
        r = arr.length - 1;
    while (l <= r) {
        // const mid = Math.floor((l + r) / 2); // 遇到大数相加会越界，改成下面方式规避大数相加的情况
        const mid = Math.floor(l + (r - l) / 2);
        if (arr[mid] === target) {
            return mid;
        } else if (arr[mid] > target) {
            r = mid - 1;
        } else {
            l = mid + 1;
        }
    }
    return -1;
}
```

## 二、二分查找的floor和ceil

```javascript
function floor() {
    // TODO
}

function ceil() {
    // TODO
}
```

## 三、二分搜索树

<p align="center"><img src=https://linmingdao.github.io/blog/assets/tech/012004_00.png></p>
<p align="center"><img src=https://linmingdao.github.io/blog/assets/tech/012004_01.png></p>

```javascript
class BSTNode {
    constructor(key, value) {
        this.key = key;
        this.value = value;
        this.left = null;
        this.right = null;
    }
}

class BST {
    constructor() {
        this.root = null;
        this.count = 0;
    }

    size() {
        return this.count;
    }

    isEmpty() {
        return this.count === 0;
    }

    insert(key, value) {
        // 插入每次都需要从根节点开始，所以插入后需要更新根节点
        this.root = this.__insert(this.root, key, value);
    }

    // 二叉搜索树的插入操作不会出现swap操作，与堆的插入对比一下
    __insert(node, key, value) {
        if (node === null) {
            this.count++;
            return new BSTNode(key, value);
        }

        if (node.key === key) {
            // 更新节点
            node.value = value;
        } else if (key > node.key) {
            // 走右子节点
            node.right = this.__insert(node.right, key, value);
        } else {
            // 走左子节点
            node.left = this.__insert(node.left, key, value);
        }

        return node;
    }

    contain(key) {
        return this.__contain(this.root, key);
    }

    __contain(node, key) {
        if (node === null) {
            return false;
        } else if (node.key === key) {
            return true;
        } else if (node.key > key) {
            return this.__contain(node.left, key);
        } else {
            return this.__contain(node.right, key);
        }
    }

    search(key) {
        return this.__search(this.root, key);
    }

    __search(node, key) {
        if (node === null) {
            return null;
        } else if (node.key === key) {
            return node;
        } else if (node.key > key) {
            return this.__search(node.left, key);
        } else {
            return this.__search(node.right, key);
        }
    }

    // 深度优先遍历：前序、中序 以及 后续遍历
    // 前序遍历
    preOrder() {
        this.__preOrder(this.root);
    }

    __preOrder(node) {
        if (node !== null) {
            console.log(node.key);
            this.__preOrder(node.left);
            this.__preOrder(node.right);
        }
    }

    // 中序遍历
    inOrder() {
        this.__inOrder(this.root);
    }

    __inOrder(node) {
        if (node !== null) {
            this.__inOrder(node.left);
            console.log(node.key);
            this.__inOrder(node.right);
        }
    }

    // 后续遍历
    postOrder() {
        this.__postOrder(this.root);
    }

    __postOrder(node) {
        if (node !== null) {
            this.__postOrder(node.left);
            this.__postOrder(node.right);
            console.log(node.key);
        }
    }

    /**
     * 后续遍历的一个应用：释放节点空间
     */
    destroy(node) {
        if (node !== null) {
            this.destroy(node.left);
            this.destroy(node.right);
            node = null;
            this.count--;
        }
    }

    // 层序遍历（广度优先遍历），需要借助队列实现
    levelOrder() {
        // (unshift)-> ====== ->(pop)
        const q = [];
        q.unshift(this.root);
        while (q.length) {
            const node = q.pop();
            console.log(node.key);
            node.left && q.unshift(node.left);
            node.right && q.unshift(node.right);
        }
    }

    // 寻找最小值节点
    min() {
        return this.__min(this.root);
    }

    __min(node) {
        if (node.left === null) return node;
        return this.__min(node.left);
    }

    // 寻找最大值节点
    max() {
        return this.__max(this.root);
    }

    __max() {
        if (node.right === null) return node;
        return this.__max(node.right);
    }

    // 删除最小节点，返回被删除的节点，还需要更新根节点
    removeMin() {
        if (this.root) {
            this.root = this.__removeMin(this.root);
        }
    }

    __removeMin(node) {
        if (node.left === null) {
            this.count--;
            return node.right;
        } else {
            node.left = this.__removeMin(node.left);
            return node;
        }
    }

    // 删除最大节点，返回被删除的节点，还需要更新根节点
    removeMax() {
        if (this.root) {
            this.root = this.__removeMax(this.root);
        }
    }

    __removeMax(node) {
        if (node.right === null) {
            this.count--;
            return node.left
        } else {
            node.right = this.__removeMax(node.right);
            return node;
        }
    }
}
```

应用：利用二分搜索树对圣经中的单词进行统计，统计出【god】这个单词出现的频率
