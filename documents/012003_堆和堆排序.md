# 堆和堆排序

### 一、 引子，优先队列的实现方式

普通队列，优先队列

|        | 入队  | 出队  |
|  ----  | ---- | ----  |
| 普通数组  | O(1) | O(n) |
| 顺序数组  | O(n) | O(1) |
| 堆  | O(lgn) | O(lgn) |

### 二、 堆

堆（Heap），堆通常是一个可以被看做一棵完全二叉树的数组对象，堆总是满足下列性质：
* 堆中某个结点的值总是不大于或不小于其父结点的值(最大堆、最小堆)；
* 堆总是一棵```完全二叉树```。

<p align="center"><img src=https://linmingdao.github.io/blog/assets/tech/012003_00.jpeg></p>

### 三、数组实现二叉堆

<p align="center"><img src=https://linmingdao.github.io/blog/assets/tech/012003_01.jpeg></p>

```javascript
class MaxHeap {
    constructor(capacity) {
        this.count = 0;
        this.capacity = capacity;
        this.data = new Array(capacity + 1);
    }

    size() {
        return this.count;
    }

    isEmpty() {
        return this.count === 0;
    }

    capacity() {
        return this.capacity;
    }

    parent(k) {
        return Math.floor(k / 2);
    }

    lChild(k) {
        return 2 * k;
    }

    rChild(k) {
        return 2 * k + 1;
    }

    insert(n) {
        if (this.capacity >= this.count + 1) {
            this.data[this.count + 1] = n;
            this.count++;
            this.shiftUp(this.count);
        } else {
            console.warning('堆的大小不够');
        }
    }

    shiftUp(k) {
        while (k > 1 && this.data[k] > this.data[this.parent(k)]) {
            [this.data[k], this.data[this.parent(k)]] = [this.data[this.parent(k)], this.data[k]];
            k = this.parent(k);
        }
    }

    extractMax() {
        if (this.count === 0) return null;
        const ret = this.data[1];
        [this.data[1], this.data[this.count]] = [this.data[this.count], this.data[1]];
        this.count--;
        this.shiftDown(1);
        return ret;
    }

    shiftDown(k) {
        while (this.lChild(k) <= this.count) {
            let j = this.lChild(k);
            const r = this.rChild(k);
            // 左右孩子都有，右孩子比较大
            if (r <= this.count && this.data[r] > this.data[j]) {
                j += 1;
            }

            if (this.data[k] >= this.data[j]) break;

            [this.data[k], this.data[j]] = [this.data[j], this.data[k]];
            k = j;
        }
    }
}
```
