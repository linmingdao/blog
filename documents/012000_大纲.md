# 简单算法

[es6入门教程](https://es6.ruanyifeng.com/)
[JavaScript标准库](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects)

## 一、字符串

### 1、反转字符串中的单词（还有没有其他思路）

* JavaScript原生api很重要

```javascript
// 使用数据api: arr.reverse()
```

### 2、计数二进制子串

[leetcode](https://leetcode-cn.com/problems/count-binary-substrings/)

* 如何找到规律
* 正则很重要 -> 重点熟悉js字符串的正则api
* ^，位运算符 -> 计算机基础知识
* str.slice，str.match，动态创建正则，静态正则表达式

```javascript
var countBinarySubstrings = function(s) {
    let n = 0,
        current = 1,
        pre = 0;
    for (let i = 0, len = s.length - 1; i < len; i++) {
        if (s[i] === s[i + 1]) {
            current++;
        } else {
            pre = current;
            current = 1;
        }
        // 这里需要特别注意
        if (current <= pre) n++;
    }
    return n;
}
```

# 数据结构

## 一、栈

先进后出，栈顶，栈底，push往栈添加元素，pop从栈顶弹出元素

* 数组的开始是栈顶，数据的结尾是栈底
* 改变原数组的几个方法：
  + arr.push，数组末尾添加元素，返回新长度
  + arr.unshift，在数据的开头添加元素，返回新长度
  + arr.shift，删除数组第一个元素，返回删除的元素
  + arr.pop，删除数组最后一个元素，返回删除的元素
* arr.reduce

[棒球比赛](https://leetcode-cn.com/problems/baseball-game/submissions/)

```javascript
var calPoints = function(ops) {
    let currentPoints = [];
    while (ops.length) {
        let op = ops.shift();
        switch (op) {
            case 'C': {
                currentPoints.length && currentPoints.pop();
                break;
            }
            case 'D': {
                currentPoints.push(currentPoints[currentPoints.length - 1] * 2);
                break;
            }
            case '+': {
                currentPoints.push(currentPoints[currentPoints.length - 1] + currentPoints[currentPoints.length - 2]);
                break;
            }
            default: {
                currentPoints.push(Number(op));
            }
        }
    }
    return currentPoints.reduce((pre, next) => pre + next);
};
```

[最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/)

```javascript
// TODO
```

## 二、队列

先进先出(FIFO)

[设计循环队列](https://leetcode-cn.com/problems/design-circular-queue/)

```javascript
// TODO
```

[任务调度器](https://leetcode-cn.com/problems/task-scheduler/)

```javascript
// TODO
```

# 数据结构基础

## 一、排序基础（O(n^2)）

### 1、选择排序

假如是数字从小到大进行排序，每次选择最小的元素和还未排序的元素互换位置

```javascript
// 选择排序
function selectionSort(arr = [8, 2, 4, 9, 3, 7, 1, 6, 5]) {
    const len = arr.length;
    for (let i = 0; i < len; i++) {
        // 先找到最小的元素
        let minIdx = i;
        for (let j = i + 1; j < len; j++) { // 不可中断的循环
            if (arr[j] < arr[minIdx]) {
                minIdx = j;
            }
        }

        // 交换位置
        if (i !== minIdx) {
            [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];
        }
    }

    return arr;
}
```

### 2、插入排序

```javascript
// BAD，没有下面的易懂
function insertionSort(arr = [8, 2, 4, 9, 3, 7, 1, 6, 5]) {
    const len = arr.length;
    for (let i = 1; i < len; i++) {
        let idx = i;
        for (let j = i - 1; j >= 0; j--) {
            if (arr[idx] < arr[j]) {
                [arr[idx], arr[j]] = [arr[j], arr[idx]];
                idx = j;
            }
        }
    }
    return arr;
}

// GOOD
function insertionSort(arr = [8, 2, 4, 9, 3, 7, 1, 6, 5]) {
    const len = arr.length;
    for (let i = 1; i < len; i++) {
        for (let j = i; j > 0 && arr[j] < arr[j - 1]; j--) {
            // 每次都在交换
            [arr[j], arr[j - 1]] = [arr[j - 1], arr[j]];
        }
    }
    return arr;
}
```

```javascript
// 插入排序的优化：插入排序再近乎有序的情况下性能很高
function insertionSort(arr = [8, 2, 4, 9, 3, 7, 1, 6, 5]) {
    const len = arr.length;
    for (let i = 1; i < len; i++) {
        const val = arr[i];
        let j = i;
        for (; j > 0 && val < arr[j - 1]; j--) { // 可中断的循环
            arr[j] = arr[j - 1];
        }
        arr[j] = val;
    }
    return arr;
}
```

### 3、希尔排序

```javascript
// 希尔排序
function shellSort() {

}
```

### 4、冒泡排序

```javascript
// 冒泡排序
function bubbleSort() {

}
```

## 二、高级排序（O(n*logn)）

### 1、归并排序

```javascript
// 写出归并的大致逻辑
function mergeSort(arr = [8, 2, 4, 9, 3, 7, 1, 6, 5]) {
    // 从下到上不断合并数组
    function __merge(arr, l, mid, r) {
        // TODO
    }

    // 从上到下不断平分数组
    function __mergeSort(arr, l, r) {
        // 递归结束的条件
        if (l >= r) return;

        const mid = (l + r) / 2;
        __mergeSort(arr, l, mid);
        __mergeSort(arr, mid + 1, r);
        __merge(arr, l, mid, r);
    }

    __mergeSort(arr, 0, arr.length - 1);

    return arr;
}
```

```javascript
function mergeSort(arr = [13, 8, 2, 4, 12, 9, 3, 7, 11, 1, 6, 5, 10, 14]) {
    // 从下到上不断合并数组
    function __merge(arr, l, mid, r) {
        const aux = arr.slice(l, r + 1); // auxiliary(辅助)的缩写
        let k = l,
            i = l,
            j = mid + 1;
        for (; k <= r; k++) {
            if (i > mid) {
                arr[k] = aux[j - l];
                j++;
            } else if (j > r) {
                arr[k] = aux[i - l];
                i++;
            } else if (aux[i - l] > aux[j - l]) {
                arr[k] = aux[j - l];
                j++;
            } else {
                arr[k] = aux[i - l];
                i++;
            }
        }
    }

    // 从上到下不断平分数组
    function __mergeSort(arr, l, r) {
        // 递归结束的条件
        if (l >= r) return;

        const mid = Math.floor((l + r) / 2);
        __mergeSort(arr, l, mid);
        __mergeSort(arr, mid + 1, r);
        __merge(arr, l, mid, r);
    }

    __mergeSort(arr, 0, arr.length - 1);

    return arr;
}
```

### 2、快速排序

```javascript
function quickSort(arr = [8, 2, 4, 9, 3, 7, 1, 6, 5]) {
    function __partition(arr, l, r) {
        const v = arr[l];
        let j = l;
        for (let i = l + 1; i <= r; i++) {
            if (arr[i] < v) {
                [arr[j + 1], arr[i]] = [arr[i], arr[j + 1]];
                j++;
            }
        }
        [arr[l], arr[j]] = [arr[j], arr[l]];

        return j;
    }

    function __quickSort(arr, l, r) {
        // 递归结束的条件
        if (l >= r) return;

        let p = __partition(arr, l, r);
        __quickSort(arr, l, p - 1);
        __quickSort(arr, p + 1, r);
    }

    __quickSort(arr, 0, arr.length - 1);

    return arr;
}
```

双路快排

三路快排

## 三、堆和堆排序

### 1、 引子，优先队列的实现方式

普通队列，优先队列

|        | 入队  | 出队  |
|  ----  | ---- | ----  |
| 普通数组  | O(1) | O(n) |
| 顺序数组  | O(n) | O(1) |
| 堆  | O(lgn) | O(lgn) |

### 2、 堆

堆（Heap），堆通常是一个可以被看做一棵完全二叉树的数组对象，堆总是满足下列性质：
* 堆中某个结点的值总是不大于或不小于其父结点的值(最大堆、最小堆)；
* 堆总是一棵```完全二叉树```。

### 3、数组实现二叉堆

## 四、二分搜索树

## 五、并查集

## 六、图的基础

## 七、最小生成树

## 八、最短路径
