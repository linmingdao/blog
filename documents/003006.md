# webpack@4.x.x 之高级概念

## 一、Tree Shaking

Tree Shaking 只支持 ES Module 引入的方式，即：import
[WHY?](https://tsejx.github.io/webpack-guidebook/principle-analysis/operational-principle/tree-shaking#pure_funcs)

开发模式是默认没有 Tree Shaking 功能的，开启需要如下配置：

```javascript
{
    mode: 'development',
    optimization: {
        usedExports: true
    }
}
```

package.json

```json
{
    // sideEffects: false
    sideEffects: ["*.css", "@babel/polly-fill"]
}
```

解释：

1. 类似 @babel/polly-fill 这样的库它的作用是在 window 对象上挂载一些垫片方法，该库是没有导出的，package.json 配置 sideEffects: ["@babel/polly-fill"] 就是告诉 webpack 虽然这个库没有export任何东西，但是你不要给我Tree Shaking掉它

2. package.json 配置 sideEffects: false，表示针对我项目的所有模块都做Tree Shaking操作，不需要特殊处理某些模块

3. sideEffects: false，太暴力了，代码中的 import "xxx.css"; 也会被忽略掉，所以要根据自己项目的情况设置一下：sideEffects，比如不忽略 .css 文件，你需要加上：sideEffects: ["*.css"]

4. 开发模式开启 Tree Shaking 后，去分析打包结果会发现需要被 Shaking 掉的打包还是会被打包进去，但是 webpack 已经 对那些需要被 Shaking 掉的代码有做了标记了，仍然会被打包的原因是，开发模式下经常需要调试源代码，所以不会被去掉没有使用到的代码

5. mode 设置为 production 后，Tree Shaking 就会真正起效果了，同时 devtool 也要相应改一下，而且生产模式默认自动开启 Tree Shaking，所以 optimization 都可以不用配置，package.json 的 sideEffects 还是需要配置的

```javascript
{
    mode: 'production',
    devtool: 'cheap-module-source-map',
    // optimization: {
    //    usedExports: true
    // }
}
```

## 二、Development 和 Production 模式打包的区别

webpack-merge 模块来合并配置，生成不同环境的 webpack 配置

## 三、Code Splitting（代码分割）

### 方式1（无代码切割）：

```javascript
import _ from 'lodash'; // 第三方库，是不常变的

// 此处省略10w行业务逻辑，业务逻辑是常变的
console.log(_.join(['a', 'b', 'c'], '***'));
```

在没有 Code Splitting 的情况下，lodash 会和业务代码一起打包成一个文件，造成如下影响：

* 打包文件会很大，加载时间会很长

* 业务逻辑变更重新部署，会导致每次都要重新加载不常变更的类似 lodash 这样的第三个库文件

### 方式2（手动代码切割）：

lodash.js

```javascript
import _ from 'lodash'; // 第三方库，是不常变的
window._ = _;
```

index.js

```javascript
// 此处省略10w行业务逻辑，业务逻辑是常变的
console.log(_.join(['a', 'b', 'c'], '***'));
```

webpack打包配置：

```javascript
// 如下entry配置，会生成两个打包文件，分别是：lodash 和 index 会被依次被 HtmlWebpackPlugin 插件注入到模板html文件中
{
    entry: {
        lodash: './src/loadsh.js',
        index: './src/index.js',
    }
}
```

### 方式3（利用webpack进行自动切割，同步性质代码打包的 Code Splitting）:

index.js

```javascript
import _ from 'lodash'; // 第三方库，是不常变的

// 此处省略10w行业务逻辑，业务逻辑是常变的
console.log(_.join(['a', 'b', 'c'], '***'));
```

webpack配置

```javascript
{
    entry: {
        index: './src/index.js',
    },
    optimization: {
        splitChunks: {
            chunks: 'all'
        }
        // webpack splitChunks 的默认配置
        // splitChunks: {
        //     chunks: 'async',
        //     minSize: 30000,
        //     maxSize: 0,
        //     minChunks: 1,
        //     maxAsyncRequests: 5,
        //     maxInitialRequests: 3,
        //     automaticNameDelimiter: '~',
        //     automaticNameMaxLength: 30,
        //     name: true,
        //     cacheGroups: {
        //         vendors: {
        //             test: /[\\/]node_modules[\\/]/,
        //             priority: -10
        //         },
        //         default: {
        //             minChunks: 2,
        //             priority: -20,
        //             reuseExistingChunk: true
        //         }
        //     }
        // }
    }
}
```

### 方式4（异步性质代码打包的 Code Splitting）:

webpack无需做任何配置，会自动对异步代码进行代码分割，放置到单独的文件中
借助 babel-plugin-dynamic-import-webpack 插件开启动态 import 的实验性语法

index.js

```javascript
function getComponent() {
    // 注意：这样直接动态import('lodash')webpack会生成类似 0.js 这样的通过id生成的chunk，不直观
    // return import('lodash').then({

    // 通过webpack魔术注释来解决编译的文件名不直观问题
    return import( /* webpackChunkName: "lodash" */ 'lodash').then({
        default: _
    } => {
        const element = document.createElement('div');
        element.innerHTML = _.join(['Dell', 'Lee'], '-');
        return element;
    });
}

getComponent().then(element => {
    document.body.appendChild(element);
});
```

### webpack Code Splitting 底层实现插件 SplitChunksPlugin 配置

特别注意：虽然动态import会自动进行代码分割，但是webpack的splitChunks配置也会影响动态import的代码分割

结论是：无聊是同步代码的代码分割还是异步代码分割，splitChunksPlugin都会对其分割起作用

1. babel-plugin-dynamic-import-webpack 非babel官方的动态插件
2. webpack 魔术注释
3. SplitChunksPlugin -> chunks、cacheGroup 配置 -> 分别对同步、异步模块的打包方式的 Code Splitting 配置

```javascript
module.exports = {
    //...
    entry: {
        main: './src/index.js'
    },
    optimization: {
        // splitChunks: {} 等价于默认配置
        // splitChunks 的默认配置
        splitChunks: {
            // 只对异步代码做分割，不会对同步的代码做分割，比如不会对同步引入lodash的方式做分割，所以这里我们一般是配置成：all，对异步和同步都做分割
            // 还可以配置成：initial表示只对同步代码进行分割
            // 但是单独配置成 all 并不会立即开始对同步代码进行分割，还需要额外配置：cacheGroups
            chunks: 'async',
            // 引入的包大于30kb的才会帮你做代码分割
            minSize: 30000,
            // 对代码进行二次拆分，lodash 1mb，超过了50kb，所以webpack会尝试对1mb的lodash进行二次拆分
            // maxSize: 50000,
            maxSize: 0,
            // 比如lodash被引入了至少一次，那么就会被进行代码分割
            minChunks: 1,
            // 同时加载的模块数最多是5个，如果超出5个就不再做代码分割了
            maxAsyncRequests: 5,
            // 整个网站首页(入口页)进行加载的时候，入口文件做代码分割的时候，分割成3个就不会再进行分割了
            maxInitialRequests: 3,
            automaticNameDelimiter: '~',
            automaticNameMaxLength: 30,
            name: true,
            // 假如同时引入了node_modules的 jquery 和 lodash两个库，那么会被都打包进vendors组
            cacheGroups: {
                vendors: {
                    // 检测引入的库是否是来自node_modules，是的话，会使用这个vendors组的规则来进行代码分割
                    // 被分割的chunks会被命名成类似：vendors~main.js ==》[分割命中的cacheGroups组名][分隔符][entry配置的入口名称].js
                    test: /[\\/]node_modules[\\/]/,
                    priority: -10,
                    // 如果你不想通过默认的方式命名：vendors~main.js，你可以通过filename配置来设定输出名称
                    // filename: 'vendors.js'
                },
                default: {
                    // 没有命中vendors组的会走default配置
                    minChunks: 2,
                    priority: -20,
                    // 如果一个模块已经被打包过了，那么就复用之前打包过的
                    reuseExistingChunk: true,
                    // 如果你不想通过默认的方式命名：default~main.js，你可以通过filename配置来设定输出名称
                    // filename: 'common.js'
                }
            }
        }
    }
};
```

## 四、Lazy Loading

### 1、何为懒加载?

真正用的时候才加载，并不是 webpack 的功能，而是 es6 的动态import

```javascript
import _ from 'lodash';

async function getComponent() {
    // return import(/* webpackChunkName: "lodash" */ 'lodash').then({ default: _ } => {
    //     const ele = document.createElement('div');
    //     ele.innerHTML = _.join(['Dell', 'Lee'], '-');
    //     return ele;
    // });

    const {
        default: _
    } = await import( /* webpackChunkName: "lodash" */ "lodash");
    const ele = document.createElement('div');
    ele.innerHTML = _.join(['Dell', 'Lee'], '-');
    return ele;
}

document.addEventListener('click', () => {
    getComponent().then(ele => {
        document.body.appendChild(ele);
    });
});
```

注意：
1. webpack 会为动态加载的脚本单独生成一个chunk
2. 当调用 ES6 模块的 import() 方法（引入模块）时，必须指向模块的 .default 值，因为它才是 promise 被处理后返回的实际的 module 对象

### 2、何为chunk

因为有了代码分割，一个项目从入口文件开始会被拆分成多个js文件，那么每一个js文件就是一个chunk

## 五、preload（预加载）、prefetch（预取）

### 1、思考webpack为什么默认配置只对异步模块进行代码拆分呢?

```javascript
{
    entry: {
        index: './src/index.js',
    },
    optimization: {
        // webpack splitChunks 的默认配置
        splitChunks: {
            // 思考webpack为什么默认配置只对异步模块进行代码拆分呢?
            chunks: 'async',
            minSize: 30000,
            maxSize: 0,
            minChunks: 1,
            maxAsyncRequests: 5,
            maxInitialRequests: 3,
            automaticNameDelimiter: '~',
            automaticNameMaxLength: 30,
            name: true,
            cacheGroups: {
                vendors: {
                    test: /[\\/]node_modules[\\/]/,
                    priority: -10
                },
                default: {
                    minChunks: 2,
                    priority: -20,
                    reuseExistingChunk: true
                }
            }
        }
    }
}
```

在引入jquery、lodash之类的第三方库的时候，将这些库拆分到一个单独的chunk中，然后借助浏览器的缓存，这个只会加快网站第二次的访问速度，那么第一次的访问速度如何优化呢?

### 2、webpack推荐的代码编写的方式

command + shift + p => Coverage：查看代码覆盖率

```javascript
document.addEventListener('click', () => {
    const ele = docement.createElement('div');
    ele.innerHTML = 'Dell Lee';
    document.body.appendChild(ele);
});
```

分析上面代码的覆盖率：首页在加载这段代码的时候，下面代码首屏加载的时候根本不会运行，其实是没有必要加载的

```javascript
const ele = docement.createElement('div');
ele.innerHTML = 'Dell Lee';
document.body.appendChild(ele);
```

所以webpack推荐我们这样写代码：

click.js

```javascript
function handleClick() {
    const ele = docement.createElement('div');
    ele.innerHTML = 'Dell Lee';
    document.body.appendChild(ele);
}

export default handleClick;
```

index.js

```javascript
document.addEventListener('click', () => {
    import('./click.js').then(({
        default: handleClick
    }) => {
        handleClick();
    })
})
```

结论：
webpack其实是力推我们写异步代码，而不是同步代码，因为同步的代码的拆分只能利用到浏览器缓存，无法优化代码利用率，对项目的优化是有限的，而异步代码可以做到真正被使用的时候才加载，这就是为什么webpack SplitChunksPlugin chunks的配置是：async（缓存能带了的代码性能提升是很有限的）

但是点击按钮的时候才去动态加载，首次使用会给用户卡顿的感觉，那么如何解决这一点呢? => preload、prefetch

### 3、懒加载牺牲的用户体验可以用preload、prefetch解决

案例：
首页中点击登录按钮，因为登录按钮并不一定会被用户点击，所以其实登录按钮的点击逻辑以及登录弹窗首页不用立即加载，
而是在首页的核心逻辑加载完之后，释放带宽后，利用空闲时间再去把登录逻辑加载下来

这样既满足了首页核心逻辑加载非常快的需求，又解决了用户点击首页登录按钮不立即响应的问题

```javascript
document.addEventListener('click', () => {
    import( /* webpackPrefetch: true */ './click.js').then(({
        default: handleClick
    }) => {
        handleClick();
    })
})
```

与 prefetch 指令相比，preload 指令有许多不同之处：
* preload chunk 会在父 chunk 加载时，以并行方式开始加载。prefetch chunk 会在父 chunk 加载结束后利用空闲的时间开始加载。
* preload chunk 具有中等优先级，并立即下载。prefetch chunk 在浏览器闲置时下载。
* preload chunk 会在父 chunk 中立即请求，用于当下时刻。prefetch chunk 会用于未来的某个时刻。
* 浏览器支持程度不同。

## 六、css文件的代码分割

### 1、output.chunkFilename 配置

```javascript
{
    entry: {
        main: './src/index.js'
    },
    output: {
        filename: '[name].js',
        chunkFilename: '[name].chunk.js',
        path: path.resolve(__dirname, 'dist')
    }
}
```

以上配置：入口js文件的打包会被命名成：main.js，而入口文件依赖的其他chunk js文件会被命名成类似：vendors~lodash.chunk.js，vendors~lodash.chunk.js不会被插入到index.html文件中，他是由main.js这个打包好的js文件自己间接地去引入的

### 2、css文件的代码分割：MiniCssExtractPlugin

webpack默认处理css的方式是css-in-js，既把css打包进js文件中

```javascript
const MiniCssExtractPlugin = require("mini-css-extract-plugin");
module.exports = {
    plugins: [
        new MiniCssExtractPlugin({
            // Options similar to the same options in webpackOptions.output
            // both options are optional
            filename: "[name].css",
            chunkFilename: "[id].css"
        })
    ],
    module: {
        rules: [{
            test: /\.scss$/,
            use: [
                MiniCssExtractPlugin.loader,
                {
                    loader: 'css-loader',
                    options: {
                        importLoaders: 2
                    }
                },
                'sass-loader',
                'postcss-loader'
            ]
        }, {
            test: /\.css$/,
            use: [
                MiniCssExtractPlugin.loader,
                'css-loader',
                'postcss-loader'
            ]
        }]
    }
}
```

MiniCssExtractPlugin这个插件目前还不支持HMR，所以开发阶段为了开发效率不必使用该插件进行css代码分割

## 七、webpack与浏览器缓存

[缓存v4官方文档](https://v4.webpack.docschina.org/guides/caching/)

## 八、shim的作用

[shim官方文档](https://v4.webpack.docschina.org/guides/shimming/)

## 九、环境变量的使用方法

[环境变量官方文档](https://v4.webpack.docschina.org/guides/environment-variables/)
