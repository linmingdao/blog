# webpack@4.x.x 之高级概念

## 一、Tree Shaking

Tree Shaking 只支持 ES Module 引入的方式，即：import
[WHY?](https://tsejx.github.io/webpack-guidebook/principle-analysis/operational-principle/tree-shaking#pure_funcs)

开发模式是默认没有 Tree Shaking 功能的，开启需要如下配置：

``` javascript
{
    mode: 'development',
    devtool: 'cheap-module-eval-source-map'
    optimization: {
        usedExports: true
    }
}
```

package.json

``` json
{
  sideEffects: false
}
```

``` json
{
  sideEffects: ["@babel/polly-fill"]
}
```

解释：

1. 类似 @babel/polly-fill 这样的库它的作用是在 window 对象上挂载一些垫片方法，该库是没有导出的，package.json 配置 sideEffects: ["@babel/polly-fill"] 就是告诉 webpack 在虽然这个库没有export任何东西，但是你不要给我Tree Shaking掉它

2. package.json 配置 sideEffects: false，表示针对我项目的所有模块都做Tree Shaking操作，不需要特殊处理某些模块

3. sideEffects: false，太暴力了，代码中的 import "xxx.css"; 也会被忽略掉，所以要根据自己项目的情况设置一下：sideEffects，比如不忽略 .css 文件，你需要加上：sideEffects: ["*.css"]

4. 开发模式开启 Tree Shaking 后，去分析打包结果会发现需要被 Shaking 掉的打包还是会被打包进去，但是 webpack 已经 对那些需要被 Shaking 掉的代码有做了标记了，仍然会被打包的原因是，开发模式下经常需要调试源代码，所以不会被去掉没有使用到的代码

5. mode 设置为 production 后，Tree Shaking 就会真正起效果了，同时 devtool 也要相应改一下，而且生产模式默认自动开启 Tree Shaking，所以 optimization 都可以不用配置，package.json 的 sideEffects 还是需要配置的

``` javascript
{
    mode: 'production',
    devtool: 'cheap-module-source-map',
    // optimization: {
    //    usedExports: true
    // }
}
```

## 二、Development 和 Production 模式打包的区别

webpack-merge 模块来合并配置，生成不同环境的 webpack 配置

## 三、Code Splitting（代码分割）

### 方式1（无代码切割）：

``` javascript
import _ from 'lodash'; // 第三方库，是不常变的

// 此处省略10w行业务逻辑，业务逻辑是常变的
console.log(_.join(['a', 'b', 'c'], '***'));
```

在没有 Code Splitting 的情况下，lodash 会和业务代码一起打包成一个文件，造成如下影响：

* 打包文件会很大，加载时间会很长

* 业务逻辑变更重新部署，会导致每次都要重新加载不常变更的类似 lodash 这样的第三个库文件

### 方式2（手动代码切割）：

lodash.js

``` javascript
import _ from 'lodash'; // 第三方库，是不常变的
window._ = _;
```

index.js

``` javascript
// 此处省略10w行业务逻辑，业务逻辑是常变的
console.log(_.join(['a', 'b', 'c'], '***'));
```

webpack打包配置：

``` javascript
// 如下entry配置，会生成两个打包文件，分别是：lodash 和 index 会被依次被 HtmlWebpackPlugin 插件注入到模板html文件中
{
    entry: {
        lodash: './src/loadsh.js',
        index: './src/index.js',
    }
}
```

### 方式3（利用webpack进行自动切割，同步性质代码打包的 Code Splitting）:

index.js

``` javascript
import _ from 'lodash'; // 第三方库，是不常变的

// 此处省略10w行业务逻辑，业务逻辑是常变的
console.log(_.join(['a', 'b', 'c'], '***'));
```

webpack配置

``` javascript
{
    entry: {
        index: './src/index.js',
    },
    optimization: {
        splitChunks: {
            chunks: 'all'
        }
    }
}
```

### 方式4（异步性质代码打包的 Code Splitting）:

webpack无需做任何配置，会自动进行代码分割，放置到单独的文件中
借助 babel-plugin-dynamic-import-webpack 插件开启动态 import 的实验性语法

index.js

``` javascript
function getComponent() {
    return import('lodash').then({
        default: _
    } => {
        const element = document.createElement('div');
        element.innerHTML = _.join(['Dell', 'Lee'], '-');
        return element;
    });
}

getComponent().then(element => {
    document.body.appendChild(element);
});
```
